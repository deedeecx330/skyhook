#!/bin/python3

try:
    import ipfsApi
except:
    print("[!] Module ipfs-api not installed")
    exit()

import sqlite3
import os
import sys
import getpass
import string
import random
import shutil
import math
import threading
import multiprocessing
from Crypto.Cipher import AES
from datetime import datetime

# GLOBAL VARIABLES
#-----------------------------------------------------------------------------------------------------|

# Using infura as to not require the user to run an IPFS node
host = "https://ipfs.infura.io"
port = 5001

# Temporary directory where all the processing happens
tmpDir = "/tmp"

# History location
dbLocation = "/home/{}/.local/skyhook.db".format(getpass.getuser())

# FUNCTIONS SECTION
#-----------------------------------------------------------------------------------------------------|

usage = """
    skyhook clear history   -   Delete everything from history
    skyhook list history    -   List all entries in history
    skyhook list keys       -   List all files and their corresponding encryption keys
    
    skyhook search [file name]  -   Search history for entries matching [file name]
    skyhook delete [hash]       -   Delete an entry specified by [hash] from history
    skyhook save [hash]         -   Save a single history entry specified by [hash] to the current directory (Importable)
    
    skyhook import [path]   -   Import history from a location specified by [path]
    skyhook export [path]   -   Export history to a location specified by [path]
    
    skyhook upload [file name]  -   Upload a file specified by [file name] from the current directory to the IPFS network
    skyhook download [hash]     -   Download a file specified by [hash] from the IPFS network to the current directory
"""

peer = ipfsApi.Client(host, port)

# Test and create the connection to the database where Skyhook will store information history
try:
    connection = sqlite3.connect(dbLocation)
    cursor = connection.cursor()
    cursor.execute("CREATE TABLE IF NOT EXISTS history (name TEXT, hash TEXT, key TEXT, date TEXT)")
except:
    print("[!] Could not connect to {}".format(dbLocation))
    exit()

# Check to see if the temporary directory is really a directory on absolute path, as well as writeable
if os.path.isdir(tmpDir):
    pass
else:
    print("[!] Temporary path {} is not a valid directory".format(tmpDir))
    exit()

if os.path.isabs(tmpDir):
    pass
else:
    print("[!] Temporary path {} is not absolute".format(tmpDir))
    exit()

if os.access(tmpDir, os.W_OK) and os.access(tmpDir, os.R_OK):
    pass
else:
    print("[!] Cannot read or write to and from {}".format(tmpDir))
    exit()
    
# Aux database functions
def listDb():
    items = cursor.execute("SELECT DISTINCT name, hash, date FROM history").fetchall()
    if len(items) == 0:
        print("[!] History is empty")
        exit()
    else:
        print("\n[+] History (Name (Date) [Hash])")
        for name, hash, date in items:
            print("\n{} ({}) [{}]".format(name, date, hash))
    print()

def listKeys():
    items = cursor.execute("SELECT DISTINCT name, key FROM history").fetchall()
    if len(items) == 0:
        print("[!] History is empty")
        exit()
    else:
        print("\n[+] Keys (Name [Key])")
        for name, key in items:
            print("\n{} [{}]".format(name, key))
    print()

def clearDb():
    cursor.execute("DROP TABLE IF EXISTS history")
    connection.commit()
    print("[+] History cleared")

def searchDb(fileName):
    items = cursor.execute("SELECT DISTINCT name, hash, date FROM history WHERE name = ?", (fileName,)).fetchall()
    if len(items) == 0:
        print("[!] Could not find any entries for {}".format(fileName))
        exit()
    else:
        print("\n[+] Files (Name (Date) [Hash])")
        for name, hash, date in items:
            print("\n{} ({}) [{}]".format(name, date, hash))
    print()

def exportDb(newPath):
    try:
        shutil.copyfile(dbLocation, newPath)
        return(0)
    except:
        return(1)

def saveOne(fileHash):
    item = cursor.execute("SELECT DISTINCT name, hash, key, date FROM history WHERE hash = ?", (fileHash,)).fetchone()
    if item == None:
        return(1)
    try:
        auxcon = sqlite3.connect("{}.save".format(fileHash))
        auxcur = auxcon.cursor()
        auxcur.execute("CREATE TABLE IF NOT EXISTS history (name TEXT, hash TEXT, key TEXT, date TEXT)")
        auxcur.execute("INSERT INTO history VALUES (?, ?, ?, ?)", tuple(item))
        auxcon.commit()
    except:
        return(2)
    return(0)

def importDb(dbPath):
    try:
        with open(dbPath, "rb") as db:
            header = db.read(15)
    except:
        return(1)
    if header == b"SQLite format 3":
        try:
            auxcon = sqlite3.connect(dbPath)
            auxcur = auxcon.cursor()
            auxfetch = auxcur.execute("SELECT DISTINCT name, hash, key, date FROM history").fetchall()
            if len(auxfetch) == 0:
                return(3)
            else:
                for item in auxfetch:
                    cursor.execute("INSERT INTO history VALUES (?, ?, ?, ?)", tuple(item))
                connection.commit()
                return(0)
        except:
            return(2)
    else:
        return(2) 

def deleteItem(fileHash):
    item = cursor.execute("SELECT DISTINCT hash FROM history WHERE hash = ?", (fileHash,)).fetchone()
    if item == None:
        return(1)
    else:
        try:
            cursor.execute("DELETE FROM history WHERE hash = ?", (fileHash,))
            connection.commit()
            return(0)
        except:
            return(2)

def cleanUp(filePath):
    os.remove(filePath)

# Custom file encryption/decryption functions
separator = b" :><:><:><: "

chunkS = int(math.pow(AES.block_size, 4))
threads = int(math.pow(multiprocessing.cpu_count(), 2))

def pad(content):
    return(content + b"!" * (AES.block_size - len(content) % AES.block_size))

def enCrypt(cipher, content, fileHandle, previous):

    encrypted = cipher.encrypt(content)

    if previous == None:
        fileHandle.write(encrypted)
        exit()
    else:
        while previous.is_alive() == True:
            pass
        else:
            fileHandle.write(encrypted)
            exit()
            
def encryptFile(originalName, newName, key):

    global chunkS
    global threads

    chunkSize = chunkS
    maxThreads = threads

    iv = os.urandom(16)
    cipher = AES.new(key, AES.MODE_CBC, iv)

    outFile = open(newName, "wb")
    outFile.write(iv + separator)

    inFile = open(originalName, "rb")
    inFile.seek(0, os.SEEK_END)

    contentLength = inFile.tell()

    while contentLength % AES.block_size != 0:
        contentLength = contentLength + 1

    if contentLength <= chunkSize:
        chunkSize = contentLength
        maxThreads = 1

    parts = int(contentLength / chunkSize / maxThreads)

    for i in range(0, parts):

        seekDefault = i * chunkSize * maxThreads

        threadPool = list()
        previous = None
        last = False

        if i == parts - 1:
            last = True
            maxThreads = 1
        
        for x in range(0, maxThreads):

            inFile.seek(seekDefault + x * chunkSize)

            if last == True:
                content = pad(inFile.read())
            else:
                content = inFile.read(chunkSize)

            t = threading.Thread(target=enCrypt, args=(cipher, content, outFile, previous))
            threadPool.append(t)
            previous = t

        for thread in threadPool:
            thread.start()
            thread.join()

        while previous.is_alive() == True:
            pass

    inFile.close()
    outFile.close()

def deCrypt(cipher, content, fileHandle, padded, previous):

    decrypted = cipher.decrypt(content)

    if padded == True:
        decrypted = decrypted.rstrip(b"!")

    if previous == None:
        fileHandle.write(decrypted)
        exit()
    else:
        while previous.is_alive() == True:
            pass
        else:
            fileHandle.write(decrypted)
            exit()

def decryptFile(oldName, newName, key):

    global chunkS
    global threads

    chunkSize = chunkS
    maxThreads = threads

    inFile = open(oldName, "rb")
    outFile = open(newName, "wb")

    iv = inFile.read(16)

    skip = len(iv + separator)
    cipher = AES.new(key, AES.MODE_CBC, iv)

    inFile.seek(0, os.SEEK_END)

    contentLength = inFile.tell() - skip

    if contentLength <= chunkSize:
        chunkSize = contentLength
        maxThreads = 1

    parts = int(contentLength / chunkSize / maxThreads)

    for i in range(0, parts):

        seekDefault = i * chunkSize * maxThreads + skip
        
        threadPool = list()
        previous = None
        last = False
        
        padded = False

        if i == parts - 1:
            last = True
            maxThreads = 1
            padded = True

        for x in range(0, maxThreads):

            inFile.seek(seekDefault + x * chunkSize)

            if last == True:
                content = inFile.read()
            else:
                content = inFile.read(chunkSize)

            t = threading.Thread(target=deCrypt, args=(cipher, content, outFile, padded, previous))
            threadPool.append(t)
            previous = t

        for thread in threadPool:
            thread.start()
            thread.join()

        while previous.is_alive() == True:
            pass

    inFile.close()
    outFile.close()

# File upload/download functions featuring automatic encryption of files before they are
# sent out to the IPFS network
def getRandomString():
    return("".join(random.choice(string.ascii_letters + string.digits) for i in range(32)))

def uploadFile(fileName):

    if not fileName in [f for f in os.listdir('.') if os.path.isfile(f)]:
        return(1)
    else:
        
        password = getRandomString()
        
        aesName = "{}.sky".format(fileName)
        tmpPath = "{}/{}".format(tmpDir, aesName)

        print("[+] Encrypting {}".format(fileName))

        encryptFile(fileName, tmpPath, password)

        os.chdir(tmpDir)
        print("[+] Uploading {}".format(fileName))
        try:
            result = peer.add(aesName)
        except:
            cleanUp(tmpPath)
            return(3)

        now = datetime.now()
        currentDate = now.strftime("%d/%m/%Y %H:%M:%S")
        print("[+] Adding entry to history")
        try:
            cursor.execute("INSERT INTO history VALUES (?, ?, ?, ?)", (fileName, result["Hash"], password, currentDate,))
            connection.commit()
        except:
            cleanUp(tmpPath)
            return(4)

        cleanUp(tmpPath)

        return(0)

def downloadFile(fileHash):

    try:
        fileName, password = cursor.execute("SELECT DISTINCT name, key FROM history WHERE hash = ?", (fileHash,)).fetchone()
    except:
        return(1)

    saveFile = "{}/{}".format(os.getcwd(), fileName)
    os.chdir(tmpDir)
    print("[+] Downloading {}".format(fileName))

    try:
        peer.get(fileHash)
    except:
        return(2)

    print("[+] Decrypting {}".format(fileName))
    try:
        decryptFile(fileHash, saveFile, password)
    except:
        cleanUp(fileHash)
        return(3)

    cleanUp(fileHash)

    return(fileName)

# MAIN SECTION
#-----------------------------------------------------------------------------------------------------|
def main(command, target):

    if command == "list" and target == "history":
        listDb()
        return(0)

    if command == "list" and target == "keys":
        listKeys()
        return(0)

    elif command == "clear" and target == "history":
        clearDb()
        return(0)

    elif command == "search":
        searchDb(target)
        return(0)

    elif command == "export":
        res = exportDb(target)
        if res == 1:
            print("[!] Error exporting history to {}".format(target))
            return(1)
        else:
            print("[+] Successfully exported history to {}".format(target))
            return(0)

    elif command == "save":
        res = saveOne(target)
        if res == 1:
            print("[!] Could not find {} in local history".format(target))
            return(1)
        if res == 2:
            print("[!] Error saving {} to local directory".format(target))
            return(1)
        else:
            print("[+] Successfully saved {} to local directory".format(target))
            return(0)

    elif command == "import":
        res = importDb(target)
        if res == 1:
            print("[!] Could not read {}".format(target))
            return(1)
        elif res == 2:
            print("[!] Could not import {}".format(target))
            return(1)
        elif res == 3:
            print("[!] No entries in {}".format(target))
            return(1)
        else:
            print("[+] Successfully imported {}".format(target))
            return(0)

    elif command == "delete":
        res = deleteItem(target)
        if res == 1:
            print("[!] Could not find {} in history".format(target))
            return(1)
        elif res == 2:
            print("[!] Could not delete {} from history".format(target))
            return(1)
        else:
            print("[+] Successfully deleted {} from history".format(target))
            return(0)

    elif command == "upload":
        res = uploadFile(target)
        if res == 1:
            print("[!] Could not find {}".format(target))
            return(1)
        elif res == 2:
            print("[!] Could not encrypt {}".format(target))
            return(1)
        elif res == 3:
            print("[!] Could not upload {}".format(target))
            return(1)
        elif res == 4:
            print("[!] Could not add an entry for {}".format(target))
            return(1)
        else:
            print("[+] Successfully uploaded {}".format(target))
            return(0)

    elif command == "download":
        res = downloadFile(target)
        if res == 1:
            print("[!] Could not retrieve {} from history".format(target))
            return(1)
        elif res == 2:
            print("[!] Could not download {}".format(target))
            return(1)
        elif res == 3:
            print("[!] Could not decrypt {}".format(target))
            return(1)
        else:
            print("[+] Downloaded {} successfully".format(res))
            return(0)
    else:
        print(usage)
        return(1)

if __name__ == "__main__":
    if len(sys.argv) != 3:
        print(usage)
        exit()

    command = str(sys.argv[1])
    target = str(sys.argv[2])

    main(command, target)
