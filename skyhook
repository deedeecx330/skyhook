#!/bin/python3

try:
    import ipfsApi
except:
    print("[!] Module ipfs-api not installed")
    exit()

import sqlite3
import os
import sys
import getpass
import string
import random
import shutil
from Crypto.Cipher import AES
from datetime import datetime

# GLOBAL VARIABLES
#-----------------------------------------------------------------------------------------------------|

# Using infura as to not require the user to run an IPFS node
host = "https://ipfs.infura.io"
port = 5001

# Temporary directory where all the processing happens
tmpDir = "/tmp"

# History location
dbLocation = "/home/{}/.local/skyhook.db".format(getpass.getuser())

# FUNCTIONS SECTION
#-----------------------------------------------------------------------------------------------------|

usage = """
    skyhook clear history - Delete everything from history
    skyhook list history - List all entries in history
    skyhook list keys - List all files and their corresponding encryption keys
    
    skyhook search [file name] - Search history for entries matching [file name]
    skyhook delete [hash] - Delete an entry specified by [hash] from history
    skyhook save [hash] - Save a single history entry specified by [hash] to the current directory (Importable)
    
    skyhook import [path] - Import history from a location specified by [path]
    skyhook export [path] - Export history to a location specified by [path]
    
    skyhook upload [file name] - Upload a file specified by [file name] from the current directory to the IPFS network
    skyhook download [hash] - Download a file specified by [hash] from the IPFS network to the current directory
"""

peer = ipfsApi.Client(host, port)

# Test and create the connection to the database where Skyhook will store information history
try:
    connection = sqlite3.connect(dbLocation)
    cursor = connection.cursor()
    cursor.execute("CREATE TABLE IF NOT EXISTS history (name TEXT, hash TEXT, key TEXT, date TEXT)")
except:
    print("[!] Could not connect to {}".format(dbLocation))
    exit()

# Check to see if the temporary directory is really a directory on absolute path, as well as writeable
if os.path.isdir(tmpDir):
    pass
else:
    print("[!] Temporary path {} is not a valid directory".format(tmpDir))
    exit()

if os.path.isabs(tmpDir):
    pass
else:
    print("[!] Temporary path {} is not absolute".format(tmpDir))
    exit()

if os.access(tmpDir, os.W_OK) and os.access(tmpDir, os.R_OK):
    pass
else:
    print("[!] Cannot read or write to and from {}".format(tmpDir))
    exit()
    
# Aux database functions
def listDb():
    items = cursor.execute("SELECT DISTINCT name, hash, date FROM history").fetchall()
    if len(items) == 0:
        print("[!] History is empty")
        exit()
    else:
        print("\n[+] History (Name (Date) [Hash])")
        for name, hash, date in items:
            print("\n{} ({}) [{}]".format(name, date, hash))
    print()

def listKeys():
    items = cursor.execute("SELECT DISTINCT name, key FROM history").fetchall()
    if len(items) == 0:
        print("[!] History is empty")
        exit()
    else:
        print("\n[+] Keys (Name [Key])")
        for name, key in items:
            print("\n{} [{}]".format(name, key))
    print()

def clearDb():
    cursor.execute("DROP TABLE IF EXISTS history")
    connection.commit()
    print("[+] History cleared")

def searchDb(fileName):
    items = cursor.execute("SELECT DISTINCT name, hash, date FROM history WHERE name = ?", (fileName,)).fetchall()
    if len(items) == 0:
        print("[!] Could not find any entries for {}".format(fileName))
        exit()
    else:
        print("\n[+] Files (Name (Date) [Hash])")
        for name, hash, date in items:
            print("\n{} ({}) [{}]".format(name, date, hash))
    print()

def exportDb(newPath):
    try:
        shutil.copyfile(dbLocation, newPath)
        return(0)
    except:
        return(1)

def saveOne(fileHash):
    item = cursor.execute("SELECT DISTINCT name, hash, key, date FROM history WHERE hash = ?", (fileHash,)).fetchone()
    if item == None:
        return(1)
    try:
        auxcon = sqlite3.connect("{}.save".format(fileHash))
        auxcur = auxcon.cursor()
        auxcur.execute("CREATE TABLE IF NOT EXISTS history (name TEXT, hash TEXT, key TEXT, date TEXT)")
        auxcur.execute("INSERT INTO history VALUES (?, ?, ?, ?)", tuple(item))
        auxcon.commit()
    except:
        return(2)
    return(0)

def importDb(dbPath):
    try:
        with open(dbPath, "rb") as db:
            header = db.read(15)
    except:
        return(1)
    if header == b"SQLite format 3":
        try:
            auxcon = sqlite3.connect(dbPath)
            auxcur = auxcon.cursor()
            auxfetch = auxcur.execute("SELECT DISTINCT name, hash, key, date FROM history").fetchall()
            if len(auxfetch) == 0:
                return(3)
            else:
                for item in auxfetch:
                    cursor.execute("INSERT INTO history VALUES (?, ?, ?, ?)", tuple(item))
                connection.commit()
                return(0)
        except:
            return(2)
    else:
        return(2) 

def deleteItem(fileHash):
    item = cursor.execute("SELECT DISTINCT hash FROM history WHERE hash = ?", (fileHash,)).fetchone()
    if item == None:
        return(1)
    else:
        try:
            cursor.execute("DELETE FROM history WHERE hash = ?", (fileHash,))
            connection.commit()
            return(0)
        except:
            return(2)

def cleanUp(filePath):
    os.remove(filePath)

# Custom file encryption/decryption functions
separator = b" :><:><:><: "

def pad(content):
    return(content + b"\x00" * (AES.block_size - len(content) % AES.block_size))

def extractData(filename):

    inFile = open(filename, "rb")
    iv, content = inFile.read().split(separator)
    inFile.close()

    inFile = open(filename, "wb")
    inFile.seek(0)
    inFile.truncate()
    inFile.write(content)
    inFile.close()

    inFile = open(filename, "rb")
    length = int(len(content) / AES.block_size)

    return(iv, length, inFile)

def encryptFile(originalName, newName, key):

    iv = os.urandom(16)

    outFile = open(newName, "wb")
    outFile.write(iv + separator)

    inFile = open(originalName, "rb")

    cipher = AES.new(key, AES.MODE_CBC, iv)
    length = int(len(pad(inFile.read())) / AES.block_size)

    for i in range(0, length):

        inFile.seek(i * AES.block_size)

        if i == length - 1:
            toCrypt = pad(inFile.read(AES.block_size))
        else:
            toCrypt = inFile.read(AES.block_size)

        encContent = cipher.encrypt(toCrypt)
        outFile.write(encContent)
    
    inFile.close()
    outFile.close()

def decryptFile(oldName, newName, key):

    iv, length, inFile = extractData(oldName)
    
    outFile = open(newName, "wb")

    cipher = AES.new(key, AES.MODE_CBC, iv)

    for i in range(0, length):

        inFile.seek(i * AES.block_size)
        content = inFile.read(AES.block_size)

        if i == length - 1:
            decContent = cipher.decrypt(content).rstrip(b"\x00")
        else:
            decContent = cipher.decrypt(content)
        outFile.write(decContent)

    inFile.close()
    outFile.close()

# File upload/download functions featuring automatic encryption of files before they are
# sent out to the IPFS network
def getRandomString():
    return("".join(random.choice(string.ascii_letters + string.digits) for i in range(32)))

def uploadFile(fileName):

    if not fileName in [f for f in os.listdir('.') if os.path.isfile(f)]:
        return(1)
    else:
        
        password = getRandomString()
        
        aesName = "{}.sky".format(fileName)
        tmpPath = "{}/{}".format(tmpDir, aesName)

        print("[+] Encrypting {}".format(fileName))

        encryptFile(fileName, tmpPath, password)

        os.chdir(tmpDir)
        print("[+] Uploading {}".format(fileName))
        try:
            result = peer.add(aesName)
        except:
            cleanUp(tmpPath)
            return(3)

        now = datetime.now()
        currentDate = now.strftime("%d/%m/%Y %H:%M:%S")
        print("[+] Adding entry to history")
        try:
            cursor.execute("INSERT INTO history VALUES (?, ?, ?, ?)", (fileName, result["Hash"], password, currentDate,))
            connection.commit()
        except:
            cleanUp(tmpPath)
            return(4)

        cleanUp(tmpPath)

        return(0)

def downloadFile(fileHash):

    try:
        fileName, password = cursor.execute("SELECT DISTINCT name, key FROM history WHERE hash = ?", (fileHash,)).fetchone()
    except:
        return(1)

    saveFile = "{}/{}".format(os.getcwd(), fileName)
    os.chdir(tmpDir)
    print("[+] Downloading {}".format(fileName))

    try:
        peer.get(fileHash)
    except:
        return(2)

    print("[+] Decrypting {}".format(fileName))
    try:
        decryptFile(fileHash, saveFile, password)
    except:
        cleanUp(fileHash)
        return(3)

    return(fileName)

# MAIN SECTION
#-----------------------------------------------------------------------------------------------------|
def main(command, target):

    if command == "list" and target == "history":
        listDb()
        return(0)

    if command == "list" and target == "keys":
        listKeys()
        return(0)

    elif command == "clear" and target == "history":
        clearDb()
        return(0)

    elif command == "search":
        searchDb(target)
        return(0)

    elif command == "export":
        res = exportDb(target)
        if res == 1:
            print("[!] Error exporting history to {}".format(target))
            return(1)
        else:
            print("[+] Successfully exported history to {}".format(target))
            return(0)

    elif command == "save":
        res = saveOne(target)
        if res == 1:
            print("[!] Could not find {} in local history".format(target))
            return(1)
        if res == 2:
            print("[!] Error saving {} to local directory".format(target))
            return(1)
        else:
            print("[+] Successfully saved {} to local directory".format(target))
            return(0)

    elif command == "import":
        res = importDb(target)
        if res == 1:
            print("[!] Could not read {}".format(target))
            return(1)
        elif res == 2:
            print("[!] Could not import {}".format(target))
            return(1)
        elif res == 3:
            print("[!] No entries in {}".format(target))
            return(1)
        else:
            print("[+] Successfully imported {}".format(target))
            return(0)

    elif command == "delete":
        res = deleteItem(target)
        if res == 1:
            print("[!] Could not find {} in history".format(target))
            return(1)
        elif res == 2:
            print("[!] Could not delete {} from history".format(target))
            return(1)
        else:
            print("[+] Successfully deleted {} from history".format(target))
            return(0)

    elif command == "upload":
        res = uploadFile(target)
        if res == 1:
            print("[!] Could not find {}".format(target))
            return(1)
        elif res == 2:
            print("[!] Could not encrypt {}".format(target))
            return(1)
        elif res == 3:
            print("[!] Could not upload {}".format(target))
            return(1)
        elif res == 4:
            print("[!] Could not add an entry for {}".format(target))
            return(1)
        else:
            print("[+] Successfully uploaded {}".format(target))
            return(0)

    elif command == "download":
        res = downloadFile(target)
        if res == 1:
            print("[!] Could not retrieve {} from history".format(target))
            return(1)
        elif res == 2:
            print("[!] Could not download {}".format(target))
            return(1)
        elif res == 3:
            print("[!] Could not decrypt {}".format(target))
            return(1)
        else:
            print("[+] Downloaded {} successfully".format(res))
            return(0)
    else:
        print(usage)
        return(1)

if __name__ == "__main__":
    if len(sys.argv) != 3:
        print(usage)
        exit()

    command = str(sys.argv[1])
    target = str(sys.argv[2])

    main(command, target)
