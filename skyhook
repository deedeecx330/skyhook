#!/bin/python3

try:
    import ipfsApi
except:
    print("[!] Module ipfs-api not installed")
    exit()

import sqlite3
import os
import stat
import sys
import getpass
import string
import random
import re
import shutil
from Crypto import Random
from Crypto.Cipher import AES
from datetime import datetime

# GLOBAL VARIABLES
#-----------------------------------------------------------------------------------------------------|

# Using infura as to not require the user to run an IPFS node
host = "https://ipfs.infura.io"
port = 5001

# Temporary directory where all the processing happens
tmpDir = "/tmp"

# History location
dbLocation = "/home/{}/.local/skyhook.db".format(getpass.getuser())

# FUNCTIONS SECTION
#-----------------------------------------------------------------------------------------------------|

usage = """
    skyhook clear history - Delete everything from history
    skyhook list history - List all entries in history
    skyhook list keys - List all files and their corresponding encryption keys
    
    skyhook search [file name] - Search history for entries matching [file name]
    skyhook delete [hash] - Delete an entry specified by [hash] from history
    skyhook save [hash] - Save a single history entry specified by [hash] to the current directory (Importable)
    
    skyhook import [path] - Import history from a location specified by [path]
    skyhook export [path] - Export history to a location specified by [path]
    
    skyhook upload [file name] - Upload a file specified by [file name] from the current directory to the IPFS network
    skyhook download [hash] - Download a file specified by [hash] from the IPFS network to the current directory
"""

peer = ipfsApi.Client(host, port)

# Test and create the connection to the database where Skyhook will store information history
try:
    connection = sqlite3.connect(dbLocation)
    cursor = connection.cursor()
    cursor.execute("CREATE TABLE IF NOT EXISTS history (name TEXT, hash TEXT, key TEXT, date TEXT)")
except:
    print("[!] Could not connect to {}".format(dbLocation))
    exit()

# Check to see if the temporary directory is really a directory on absolute path, as well as writeable
if os.path.isdir(tmpDir):
    pass
else:
    print("[!] Temporary path {} is not a valid directory".format(tmpDir))
    exit()

if os.path.isabs(tmpDir):
    pass
else:
    print("[!] Temporary path {} is not absolute".format(tmpDir))
    exit()

if os.access(tmpDir, os.W_OK) and os.access(tmpDir, os.R_OK):
    pass
else:
    print("[!] Cannot read or write to and from {}".format(tmpDir))
    exit()
    
# Aux database functions
def listDb():
    items = cursor.execute("SELECT DISTINCT name, hash, date FROM history").fetchall()
    if len(items) == 0:
        print("[!] History is empty")
    else:
        print("\n[+] History (Name (Date) [Hash])")
        for name, hash, date in items:
            print("\n{} ({}) [{}]".format(name, date, hash))
    print()

def listKeys():
    items = cursor.execute("SELECT DISTINCT name, key FROM history").fetchall()
    if len(items) == 0:
        print("[!] History is empty")
    else:
        print("\n[+] Keys (Name [Key])")
        for name, key in items:
            print("\n{} [{}]".format(name, key))
    print()

def clearDb():
    cursor.execute("DROP TABLE IF EXISTS history")
    connection.commit()
    print("[+] History cleared")

def searchDb(fileName):
    items = cursor.execute("SELECT DISTINCT name, hash, date FROM history WHERE name = ?", (fileName,)).fetchall()
    if len(items) == 0:
        print("[!] Could not find any entries for {}".format(fileName))
    else:
        print("\n[+] Files (Name (Date) [Hash])")
        for name, hash, date in items:
            print("\n{} ({}) [{}]".format(name, date, hash))
    print()

def exportDb(newPath):
    try:
        shutil.copyfile(dbLocation, newPath)
        return(0)
    except:
        return(1)

def saveOne(fileHash):
    item = cursor.execute("SELECT name, hash, key, date FROM history WHERE hash = ?", (fileHash,)).fetchone()
    if item == None:
        return(1)
    try:
        auxcon = sqlite3.connect("{}.save".format(fileHash))
        auxcur = auxcon.cursor()
        auxcur.execute("CREATE TABLE IF NOT EXISTS history (name TEXT, hash TEXT, key TEXT, date TEXT)")
        auxcur.execute("INSERT INTO history VALUES (?, ?, ?, ?)", tuple(item))
        auxcon.commit()
    except:
        return(2)
    return(0)

def importDb(dbPath):
    try:
        with open(dbPath, "rb") as db:
            header = db.read(15)
    except:
        return(1)
    if header == b"SQLite format 3":
        try:
            auxcon = sqlite3.connect(dbPath)
            auxcur = auxcon.cursor()
            auxfetch = auxcur.execute("SELECT DISTINCT name, hash, key, date FROM history").fetchall()
            if len(auxfetch) == 0:
                return(3)
            else:
                for name, hash, key, date in auxfetch:
                    cursor.execute("INSERT INTO history VALUES (?, ?, ?, ?)", (name, hash, key, date,))
                connection.commit()
                return(0)
        except:
            return(2)
    else:
        return(2) 

def deleteItem(fileHash):
    item = cursor.execute("SELECT hash FROM history WHERE hash = ?", (fileHash,)).fetchone()
    if item == None:
        return(1)
    else:
        try:
            cursor.execute("DELETE FROM history WHERE hash = ?", (fileHash,))
            connection.commit()
            return(0)
        except:
            return(2)


# Custom file encryption/decryption functions
separator = b" :><:><:><: "

def pad(message):
    return(message + b"\0" * (AES.block_size - len(message) % AES.block_size))

def cleanUp(filePath):
    os.remove(filePath)

def encryptFile(originalName, aesName, key):

    with open(originalName, "rb") as infile:
        contents = pad(infile.read())
        iv = os.urandom(16)
        cipher = AES.new(key, AES.MODE_CBC, iv)
        encryptedContents = cipher.encrypt(contents)

    with open(aesName, "wb") as outfile:
        outfile.write(iv + separator + encryptedContents)

def decryptFile(aesName, originalName, key):

    with open(aesName, "rb") as infile:
        iv, contents = infile.read().split(separator)
        cipher = AES.new(key, AES.MODE_CBC, iv)
        decryptedContents = cipher.decrypt(contents).rstrip(b"\0")

    with open(originalName, "wb") as outfile:
        outfile.write(decryptedContents)

# File upload/download functions featuring automatic encryption of files before they are
# sent out to the IPFS network
def getRandomString():
    return("".join(random.choice(string.ascii_letters + string.digits) for i in range(32)))

def uploadFile(fileName):
    
    files = [f for f in os.listdir('.') if os.path.isfile(f)]

    if not fileName in files:
        return(1)
    else:
        password = getRandomString()
        aesName = "{}.sky".format(fileName)
        tmpPath = "{}/{}".format(tmpDir, aesName)

        print("[+] Encrypting {}".format(fileName))
        try:
            encryptFile(fileName, tmpPath, password)
        except:
            cleanUp(tmpPath)
            return(2)

        os.chdir(tmpDir)
        print("[+] Uploading {}".format(fileName))
        try:
            result = peer.add(aesName)
        except:
            cleanUp(tmpPath)
            return(3)

        now = datetime.now()
        currentDate = now.strftime("%d/%m/%Y %H:%M:%S")
        print("[+] Adding entry to history")
        try:
            cursor.execute("INSERT INTO history VALUES (?, ?, ?, ?)", (fileName, result["Hash"], password, currentDate,))
            connection.commit()
        except:
            cleanUp(tmpPath)
            return(4)

        cleanUp(tmpPath)

        return(0)

def downloadFile(fileHash):

    try:
        fileName, password = cursor.execute("SELECT name, key FROM history WHERE hash = ?", (fileHash,)).fetchone()
    except:
        return(1)

    saveFile = "{}/{}".format(os.getcwd(), fileName)
    os.chdir(tmpDir)
    print("[+] Downloading {}".format(fileName))

    try:
        peer.get(fileHash)
    except:
        return(2)

    print("[+] Decrypting {}".format(fileName))
    try:
        decryptFile(fileHash, saveFile, password)
    except:
        cleanUp(fileHash)
        return(3)

    return(fileName)

# MAIN SECTION
#-----------------------------------------------------------------------------------------------------|
def main(command, target):

    if command == "list" and target == "history":
        listDb()
        return(0)

    if command == "list" and target == "keys":
        listKeys()
        return(0)

    elif command == "clear" and target == "history":
        clearDb()
        return(0)

    elif command == "search":
        searchDb(target)
        return(0)

    elif command == "export":
        res = exportDb(target)
        if res == 1:
            print("[!] Error exporting history to {}".format(target))
            return(1)
        else:
            print("[+] Successfully exported history to {}".format(target))
            return(0)

    elif command == "save":
        res = saveOne(target)
        if res == 1:
            print("[!] Could not find {} in local history".format(target))
            return(1)
        if res == 2:
            print("[!] Error saving {} to local directory".format(target))
            return(1)
        else:
            print("[+] Successfully saved {} to local directory".format(target))
            return(0)

    elif command == "import":
        res = importDb(target)
        if res == 1:
            print("[!] Could not read {}".format(target))
            return(1)
        elif res == 2:
            print("[!] Could not import {}".format(target))
            return(1)
        elif res == 3:
            print("[!] No entries in {}".format(target))
            return(1)
        else:
            print("[+] Successfully imported {}".format(target))
            return(0)

    elif command == "delete":
        res = deleteItem(target)
        if res == 1:
            print("[!] Could not find {} in history".format(target))
            return(1)
        elif res == 2:
            print("[!] Could not delete {} from history".format(target))
            return(1)
        else:
            print("[+] Successfully deleted {} from history".format(target))
            return(0)

    elif command == "upload":
        res = uploadFile(target)
        if res == 1:
            print("[!] Could not find {}".format(target))
            return(1)
        elif res == 2:
            print("[!] Could not encrypt {}".format(target))
            return(1)
        elif res == 3:
            print("[!] Could not upload {}".format(target))
            return(1)
        elif res == 4:
            print("[!] Could not add an entry for {}".format(target))
            return(1)
        else:
            print("[+] Successfully uploaded {}".format(target))
            return(0)

    elif command == "download":
        res = downloadFile(target)
        if res == 1:
            print("[!] Could not retrieve {} from history".format(target))
            return(1)
        elif res == 2:
            print("[!] Could not download {}".format(target))
            return(1)
        elif res == 3:
            print("[!] Could not decrypt {}".format(target))
            return(1)
        else:
            print("[+] Downloaded {} successfully".format(res))
            return(0)
    else:
        print(usage)
        return(1)

if __name__ == "__main__":

    if len(sys.argv) != 3:
        print(usage)
        exit()

    command = str(sys.argv[1])
    target = str(sys.argv[2])

    main(command, target)
